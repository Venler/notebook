## 网页生成的过程

1. HTML代码转成Dom
2. css代码转成CSSom
3. 结合DOM和CSSOM，生产一棵渲染树
4. 生成布局，将所有渲染树的所有节点进行平面合成
5. 将布局绘制（paint）在屏幕上

这五步里面，第一步到第三步都非常快，耗时的是第四步和第五步。

**"生成布局"（flow）和"绘制"（paint）这两步，合称为"渲染"（render）。**

重排和重绘会不断触发，这是不可避免的。但是，它们非常耗费资源，是导致网页性能低下的根本原因。

**提高网页性能，就是要降低"重排"和"重绘"的频率和成本，尽量少触发重新渲染。**

一般的规则是：

> * 样式表越简单，重排和重绘就越快。
> * 重排和重绘的DOM元素层级越高，成本就越高。
> * table元素的重排和重绘成本，要高于div元素

## 提高性能的九个技巧（重排和重绘角度）

**第一条**

是上一节说到的，DOM 的多个读操作（或多个写操作），应该放在一起。不要两个读操作之间，加入一个写操作。

**第二条**

如果某个样式是通过重排得到的，那么最好缓存结果。避免下一次用到的时候，浏览器又要重排。

**第三条**

不要一条条地改变样式，而要通过改变class，或者csstext属性，一次性地改变样式。

**第四条**

尽量使用离线DOM，而不是真实的网面DOM，来改变元素样式。比如，操作Document Fragment对象，完成后再把这个对象加入DOM。再比如，使用 cloneNode\(\) 方法，在克隆的节点上进行操作，然后再用克隆的节点替换原始节点。

**第五条**

先将元素设为`display: none（`需要1次重排和重绘），然后对这个节点进行100次操作，最后再恢复显示（需要1次重排和重绘）。这样一来，你就用两次重新渲染，取代了可能高达100次的重新渲染。

**第六条**

position属性为`absolute`或`fixed`的元素，重排的开销会比较小，因为不用考虑它对其他元素的影响。

**第七条**

只在必要的时候，才将元素的display属性为可见，因为不可见的元素不影响重排和重绘。另外，`visibility : hidden`的元素只对重绘有影响，不影响重排。

## 提高性能（动画相关）

**一秒之间能够完成多少次重新渲染，这个指标就被称为"刷新率"，英文为FPS（frame per second）。**60次重新渲染，就是60FPS。

如果想达到60帧的刷新率，就意味着JavaScript线程每个任务的耗时，必须少于16毫秒。一个解决办法是使用Web Worker，主线程只用于UI渲染，然后跟UI渲染不相干的任务，都放在Worker线程。

1.window.requestAnimationFrame\(\) 方法

## 提高性能（网络相关）

1.减少http请求数量

\(1\)   减少服务器压力.

\(2\)   减少http请求头

当我们对服务器发起一个请求的时候,我们会携带着这个域名下的cookie和一些其他的信息在http头部里,然后服务器响应请求的时候也会带回一些cookie之类的头部信息.这些信息有的时候会很大,在这种请求和响应的时候会影响带宽性能.

\(3\)   减少DNS请求所耗费的时间.

> 当我们去请求一个url的时候,首先会到本地服务器里去寻找缓存中是否有解析结果,如果没有解析结果,就去根域名服务器请求,根域名服务器返回给本 地域名服务器一个所查询的域的主域名服务器的ip地址,然后我们再去请求刚才返回的ip地址的域名服务器,然后返回下一级域名的ip地址,直到我们找到域 名中所指的服务器ip,然后将结果缓存起来供下次使用,并返回此结果
>
> 对于http1.0，我们有100 条请求，就得有100次这样的重复过程；但在http1.1，keep-alive是默认的，而且现代浏览器都有DNS缓存，那么对于“100条请求”和“对100条请求合并为1条请求”这两种方案来说：
>
> \* DNS寻址由于有DNS缓存--无差别；
>
> \* 3次握手由于有keep-alive，一条和一百条都只需一次TCP握手--无差别；
>
> \* 发送报文--增多了99次的http请求头；
>
> \* 服务器解析--无差别；
>
> \* 响应内容 --增多了99次的http响应头；
>
> 只是增多了http报文头，在实际应用中，是否有大的性能差别？

\(4\)网络延迟其实是在有keep-alive情况下仍然需要请求合并的主要动力。

\(5\)**丢包率能进一步影响keep-alive下多个小文件的传输**

\(6\)经过代理服务器时可能会被断开

### 方法

\(1\). 从设计实现层面简化页面

\(2\). 合理设置 HTTP缓存

很少变化的图片资源可以直接通过 HTTP Header中的Expires设置一个很长的过期头 ;变化不频繁而又可能会变的资源可以使用 Last-Modifed来做请求验证。尽可能的让资源能够在缓存中待得更久。

\(3\). 资源合并与压缩

\(4\). CSS Sprites

\(5\). Inline Images如果是嵌入页面的话换来的是增大了页面的体积，而且无法利用浏览器缓存。使用在 CSS中的图片则更为理想一些。base64 文本文件相比原文件而言，大了一些 \(1/3\)，而经过 gzip 后两者几乎没有区别。z只建议用小图片



